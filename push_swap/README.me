Complexity :


Time Complexity: Time Complexity is defined as the number of times a particular instruction 
set is executed rather than the total time is taken. It is because the total time taken also 
depends on some external factors like the compiler used, processor’s speed, etc.

Space Complexity: Space Complexity is the total memory space required by the program for its execution.
Both are calculated as the function of input size(n). Summary

You start with two empty stacks: a and b. You are given a random list of integers via command line arguments.

Only these moves are allowed:

sa : swap a - swap the first 2 elements at the top of stack a. Do nothing if there is only one or no elements).

sb : swap b - swap the first 2 elements at the top of stack b. Do nothing if there is only one or no elements).

ss : sa and sb at the same time.

pa : push a - take the first element at the top of b and put it at the top of a. Do nothing if b is empty.

pb : push b - take the first element at the top of a and put it at the top of b. Do nothing if a is empty.

ra : rotate a - shift up all elements of stack a by 1. The first element becomes the last one.

rb : rotate b - shift up all elements of stack b by 1. The first element becomes the last one.

rr : ra and rb at the same time.

rra : reverse rotate a - shift down all elements of stack a by 1. The last element becomes the first one.

rrb : reverse rotate b - shift down all elements of stack b by 1. The last element becomes the first one.

rrr : rra and rrb at the same time. What is a stack :

its a stack is a data structure that works with LIFO principle , last in fist out, meaning the last item added to the stack 
is the first one to be out , like  a stack of plates , when i add a plate i place it on top and when i take a plate i take the top one. 

Operations explained :

Push :

this function purpose is to either push 'a' or 'b' , it moves the top element from a stack to another one , how does it work u ask :

we declare 2 pointers to each stack ;
we have a doubly linked list structure with some members data, next, prev;
we first check if the stack is empty ; the function in this case does nothing ;
we declare a variable tmp. to store the next node after the top , so we make sure we dont use the link after poping the top;
then we are ready to move the top node from a satck to the other one;
then we update the top of the stack we removed to tmp;
then we update this new top previous to NULL ;
here is an example of two stacks a, b : Call 1:

Stack a: | 4 |
Stack b: | 3 | | 2 | | 1 |
Call 2:

Stack a: | 3 | | 4 |
Stack b: | 2 | | 1 |
Call 3:

Stack a: | 2 | | 3 | | 4 |
Stack b: | 1 |
Call 4:

Stack a: | 1 | | 2 | | 3 | | 4 |
Stack b: NULL 

Swap :

this function purpose is to swap the top two nodes , and it works as follow :

we check if the stack has less than two nodes, or the stack is empty  , if so we do nothing;
we declare two variables old_head , new_head ;
we start by updating the top node of the stack to the new_head;
and we skip the new_head position which is the second after the *head=old_head , and pointes to the third node;
then we update the prev pointer of the next node  of the new_head to point to the old head 
(its position was 1 but now its 2 and 3's prev pointer pointes to 2 "old_head")
then we update the new_head's next to point to the old_head , and its prev to point to NULL; easy right :);
and finally we update the old_head's prev to point to the new_head;

here is a visual example : Initial State (Stack with Three Nodes)

| 3 | <- old_head (top of stack)
| 2 | <- new_head
| 1 |
 NULL

Step-by-Step Changes
Set *head to new_head:

| 2 | <- *head (new_head)
| 3 | <- old_head
| 1 |
 NULL

Update old_head->next to new_head->next:

| 2 | <- *head (new_head)
| 3 | -> | 1 |
 NULL

Update new_head->next to old_head:

| 2 | <- *head (new_head)
   |
   v
| 3 | -> | 1 |
 NULL

Update new_head->prev to NULL:

| 2 | <- *head (new_head)
   |
   v
| 3 | -> | 1 |
 NULL

Update old_head->prev to new_head:

| 2 | <- *head (new_head)
   |
   v
| 3 | -> | 1 |
 NULL

Final State (After Swap)

| 2 | <- *head (new top of stack)
| 3 |
| 1 |
 NULL 
 
 Rotate :

this function purpose is to move the top node of the stack to the bottom and the rest of the stack
will be shifted up by one position , and it works as follow :

we check if stack is empty or hase only one node ; if so we do nothing;
we save the first node ; we gonna move it later to the last/bottom;
we update the head , to point to the next ; we also update its previous pointer to NULL;
now we have disconnected the old head;
then we look for the last node using find_last function;
now we link the last node's next to the old first_node;
and we link the prev pointer of the old first_node to the last node;
and we update the next node of the old first_node to NULL;

 here is an example : Initial State (Stack with Three Nodes)

| 3 | <- first_node (top of stack)
| 2 |
| 1 | <- last_node
 NULL

Step-by-Step Changes
Move the Head to the Next Node:

| 2 | <- *stack (new head)
| 1 |
| 3 | <- first_node (detached)
 NULL

Find the Last Node:

The last node is still 1.
Link the Last Node to first_node:

| 2 | <- *stack (new head)
| 1 | -> | 3 | <- first_node
 NULL

Update the Pointers of first_node:

| 2 | <- *stack (new head)
| 1 | -> | 3 | <- first_node (now last)
         NULL

Final State (After Rotation)

| 2 | <- *stack (new top of stack)
| 1 |
| 3 | <- first_node (now bottom of stack)
 NULL 
 
 Reverse rotate :

this function purpose is is to move the last node of the stack to the top of the stack and the rest of
the stack will be shifted down by one position , and it works as follow :

we first check if the stack is empty or have only one node , if so there nothing t do;
we loof for the last node and the second_last to it , we loop thru the last->next ;
if there is a next to last it means there is one more node after the last which makes it the the real last ;
and we update the two variables last = last->next and second_last = last; kinda confusing i know;
then we disconnect the second_last from the list so its the new last , and the old last gonna be moved to the top;
we update the next node of the last(old last) to point to the current head;
we update its previous to NULL;
then we update the old head's prev now its on the second node to point to the new had (old last) ;
and we finally update the head to points to this new top node (old last);   easy right :);

here is an example :

Initial State (Stack with Three Nodes)

| 3 | <- head (*stack)
| 2 |
| 1 | <- last
 NULL

Step-by-Step Changes
Find last and second_last:

last: Node 1
second_last: Node 2
Disconnect the Last Node:

| 3 | <- head (*stack)
| 2 | <- second_last (new last)
 NULL

Move the Last Node to the Top:

Point the last node (1) to the current head (3).
Update pointers as follows:

| 1 | <- head (*stack)
   |
   v
| 3 |
| 2 |
 NULL

Final State (After Reverse Rotation)

| 1 | <- head (*stack, new top of the stack)
| 3 |
| 2 |
 NULL
 
 Sort three : 

this function purpose is to rearrange three nodes in a stack in ascending order , using operation like rotate,
reverse rotate , swap, and using a helper function find_max that looks for the node with the biggest value in the stack.

lets explain the helper function find_max :

this function basically iterate thru the stack to find the node with largest value , and returns a pointer to that node.
we init the max with the min long value and we keep comparing it with the value of other nodes .

now lets talk about the simple sort three function :

we first need to find the largest node ;
first case if the largest node is on top we use rotate; now its on the bottom
second case if the largest node we reverse rotate ; now its on the bottom
third case if the first node is bigger than the second we use swap ; so the lower node is on top;

we have on total 6 cases here they are : Case 1: [3, 2, 1]
Largest node: 3 (first node).
Action:
ra(a) to move 3 to the bottom → [2, 1, 3].
sa(a) to swap 2 and 1 → [1, 2, 3].

Case 2: [2, 3, 1]
Largest node: 3 (second node).
Action:
rra(a) to move 3 to the bottom → [1, 2, 3].

Case 3: [1, 3, 2]
Largest node: 3 (second node).
Action:
rra(a) to move 3 to the bottom → [2, 1, 3].
sa(a) to swap 2 and 1 → [1, 2, 3].

Case 4: [3, 1, 2]
Largest node: 3 (first node).
Action:
ra(a) to move 3 to the bottom → [1, 2, 3].

Case 5: [2, 1, 3]
Largest node: 3 (third node).
Action:
sa(a) to swap 2 and 1 → [1, 2, 3].

Case 6: [1, 2, 3]
Already sorted, no action needed. 

Initing the stack and parsing :

the purpose of this step is crucial we init the stack from a command-line argument and handle its configuration(parsing), and prepare it for the sorting operations;

we first made a function that append (ft_lstadd_back) ;
its purpose is to add a new created node at the end of a doubly linked list and here is how it work :

we first allocate memory for the new node ;
then we look for the last node in this stack ;
we update this last node next to point to our new node;
and we update the previous pointer of our new node to point to this old last node;

then we init the stack :
the purpose of this step is :
we firstly parse the command line args;
we convert them to int ;
and we all them to the stack as nodes;

here is how it works :
we loop thru av , for each argument we check for invalid input with check_for_errros;
we convert the argument using ft_atoi2;
we check for the overflow;
we check there is no duplicate number;
and at last we append this node;

we also have a function that looks for a node with the flag cheapest , we will use it later in the algorithm;
its purpose is to look for the flagged node and return it 


we also have another function that prep a stack for the push operation;
its purpose is to rotate the stack so that a specific node is on top and it works as follows :

we have a variable target , its the node that we want on top;
while the node that is on top is not the target we look for its position relative to the median;
if the target node is above median we use rotate operation ; else we use reverse rotate
 we gonna start explaining how we init the stack and sort it with the turk algorithm :

we will start with the helper function of initing the stack :

first we have a function that assigns an index to each node , so it can mark it is it above or below the
median line , and it works as follow : (current index)

we declare 2 variables , i the index and median : whom will store the the lent of the stack / 2 so we know 
where is the middle of the stack;
we loop thru each node in the stack , we assigns the current i to the index member of the node;
we check if the current index is less or equal to the median if so we flag it as true; the node is closer to the top;
we check if the current index is greater than the median, if so we flag it false; the node is closer to the bottom;

set_cheapest : 

this function purpose is to identifier the node with the lowest push cost; and it works as follows :

we declare 2 variables : cheapest_value to store the smallest amount of operation needed so far;
                                      cheapest_node : pointer to the node with the smallest push cost;
we init the cheapest value to long_max and we keep comparing the push cost against it ;
we loop thru the stack , we compare nodes against the cheapest_value, 
we update the variable of the cheapest value , and update the cheapest node as well;
we keep going thru the stack , if we find the cheapest one we flag it as true


cost_analysis_a : 

this function purpose is to calculate the push cost for each node in stack a, when moving it to its target position in stack b;
the push cost is how many moves/operation needed to bring a desired node in stack A to the top of the stack;

we first declare some variables to store the length of each stack;
we loop thru every node in the stack a, to calculate its push cost;
we calculate the push cost this way , per example if a node is at index 3 , we need 3 rotations to bring it to the top ;
we check if the node is above_median then we reverse rotate instead (we calculate the reverse rotation cost)
a->push_cost = len_a - (a->index) ; total moves = total nodes - current index ; if the stack has  5 nodes ,
and the node we want is at index 4 , the reverse rotation cost is 5 - 4 = 1;
then we check the target node as well if above median (we use rotate), and we add its moves to the push cost of a (because we have to
align b for a so its a must to add that to the push_cost),
else if its below median we use revers rotate , (we calculate its push cost) total moves = total nodes - index of the node;
by the end of this function each node in a have its push_cost calculated (the cost to bring the node on top + the cost to allign
the target node in stack b); now lets explain the init_a_to_be and init_b_to_a :

we have a helper function set_target_a ; its purpose is determine the target node in stack b for each node in stack a; and it works
as follows :

we declare a variable current_b to loop thru b;
we declare a variable target_node to store the best matching node in B for A;
and we declare a variable to store the closest smaller number in B for A;

we then loop thru the stack a;  we set the best_match to long_min;
and we loop thru stack b, and we compare the nodes , the target node in b has to be smaller than the node in A ,
and we compare the value of the node in stack b, it has to be big but only big enough to be smaller than the node A,
per example we have anode A = 25 , and we have multiple nodes in B one is 42 and one i 72 and one is 22 and one is 17 , the 22 one
is the best match because its smaller than the A node but not that small ;
if no node found we assign the target node to the largest value , i will explain the logic behind this down below :

We first gonna talk about what is a Target NODE :

What Does "Target Node" Mean?

The target node is the position in the destination stack (B) where a node from the source stack (A) can be inserted while 
keeping the destination stack sorted.
For example:

If Stack B is [3, 5, 10] (sorted ascending) and you're inserting 7 from Stack A, 7 should go between 5 and 10.

2. Why Choose a Smaller But Closest Larger Node?
When inserting a number into a sorted stack:

You want to preserve the order.
If you insert 7 after 3 but before 5 in [3, 5, 10], the stack becomes [3, 7, 5, 10], which is no longer sorted.
You want the smallest larger number to reduce moves.
Choosing 10 as the target for 7 would require unnecessary extra rotations since 7 should go between 5 and 10.

Example
Stack B: [3, 5, 10]
Node from A: 7
Target node:
It must be greater than 7 to keep the order.
It must be the smallest possible larger number, which is 10.

3. Why Choose the Largest Number if Nothing Matches?
When all nodes in B are smaller than the current node from A, there’s no "correct" spot in the sorted order. In this case:

We set the largest node in B as the target.
This allows the node from A to wrap around and be inserted at the "end" of B.
Example
Stack B: [3, 5, 10]
Node from A: 15
All numbers in B are smaller than 15, so:
Target node: The largest node in B, 10.
This ensures 15 gets inserted after 10, which maintains the order.

4. Why Not Choose the Smallest Node When No Match Exists?
Choosing the smallest node instead of the largest would:

Break the sorted order.
For example:
If 15 is inserted before 3 in [3, 5, 10], the stack becomes [15, 3, 5, 10], which is no longer sorted.
Cause unnecessary rotations when combining the stacks.
In the next steps of the algorithm, you would have to fix the misplaced number, wasting moves.

now lets explain the second function init_nodes_a :

this function purpose is to prepare the stack A before sorting operation ;
we assign indexes to nodes in a and b , and know there position regarding the median;
we then look for target node in b for each node in a;
we calculate the cost of how many operation needed to push nodes from a to b;
we then mark the node is A with the lowest push cost;
